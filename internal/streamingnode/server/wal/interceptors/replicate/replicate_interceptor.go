package replicate

import (
	"context"

	"github.com/cockroachdb/errors"

	"github.com/milvus-io/milvus/internal/streamingnode/server/wal/interceptors"
	"github.com/milvus-io/milvus/internal/streamingnode/server/wal/interceptors/replicate/replicates"
	"github.com/milvus-io/milvus/internal/util/streamingutil/status"
	"github.com/milvus-io/milvus/pkg/v2/streaming/util/message"
)

const interceptorName = "replicate"

type replicateInterceptor struct {
	replicateManager replicates.ReplicateManager
}

func (impl *replicateInterceptor) Name() string {
	return interceptorName
}

func (impl *replicateInterceptor) DoAppend(ctx context.Context, msg message.MutableMessage, appendOp interceptors.Append) (msgID message.MessageID, err error) {
	if msg.MessageType() == message.MessageTypePutReplicateConfig {
		// switch replicate mode if the message is put replicate config.
		putReplicateConfig := message.MustAsMutablePutReplicateConfigMessageV2(msg)
		if err := impl.replicateManager.SwitchReplicateMode(ctx, putReplicateConfig); err != nil {
			return nil, err
		}
		return appendOp(ctx, msg)
	}
	rh := msg.ReplicateHeader()

	// some message type like timetick, create segment, flush are generated by wal itself, so they cannot be replicated,
	if msg.MessageType().IsSelfControlled() {
		if rh != nil {
			return nil, status.NewIgnoreOperation("wal self-controlled message cannot be replicated")
		}
		return appendOp(ctx, msg)
	}

	// Begin to replicate the message.
	acker, err := impl.replicateManager.BeginReplicateMessage(ctx, msg)
	if errors.Is(err, replicates.ErrNotReplicateMessage) {
		// the message is not replicate message, so it can be ignored, write it to wal directly.
		return appendOp(ctx, msg)
	}
	if err != nil {
		return nil, err
	}

	defer func() {
		acker.Ack(err)
	}()
	return appendOp(ctx, msg)
}

func (impl *replicateInterceptor) Close() {
}
